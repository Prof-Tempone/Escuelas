<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris B치sico</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
        }
        canvas {
            background-color: #000;
            display: block;
            margin: auto;
        }
        h1 {
            color: white;
            text-align: center;
        }
    </style>
</head>
<body>

<canvas id="tetrisCanvas" width="320" height="640"></canvas>
<h1 id="score">Puntuaci칩n: 0</h1>

<script>
    const canvas = document.getElementById("tetrisCanvas");
    const ctx = canvas.getContext("2d");
    const rows = 20;
    const cols = 10;
    const blockSize = 32;
    const emptyColor = "#000";
    const colors = ["#00f", "#0f0", "#f00", "#ff0", "#0ff", "#f0f", "#f90"]; // Colores para cada pieza

    let score = 0;
    let gameBoard = Array.from({ length: rows }, () => Array(cols).fill(0));

    const pieces = [
        [[1, 1, 1, 1]], // I
        [[1, 1], [1, 1]], // O
        [[0, 1, 0], [1, 1, 1]], // T
        [[1, 1, 0], [0, 1, 1]], // Z
        [[0, 1, 1], [1, 1, 0]], // S
        [[1, 1, 1], [1, 0, 0]], // L
        [[1, 1, 1], [0, 0, 1]]  // J
    ];

    let currentPiece = null;
    let pieceX = 0;
    let pieceY = 0;

    function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (gameBoard[row][col] !== 0) {
                    drawBlock(col, row, colors[gameBoard[row][col] - 1]);
                }
            }
        }
        if (currentPiece) {
            drawPiece();
        }
    }

    function drawBlock(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
        ctx.strokeStyle = "black";
        ctx.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
    }

    function drawPiece() {
        currentPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    drawBlock(pieceX + x, pieceY + y, colors[currentPiece.color]);
                }
            });
        });
    }

    function generateNewPiece() {
        const randomIndex = Math.floor(Math.random() * pieces.length);
        currentPiece = {
            shape: pieces[randomIndex],
            color: randomIndex,
        };
        pieceX = Math.floor(cols / 2) - Math.floor(currentPiece.shape[0].length / 2);
        pieceY = 0;

        if (collision()) {
            gameOver();
        }
    }

    function collision() {
        return currentPiece.shape.some((row, y) => {
            return row.some((value, x) => {
                if (value !== 0) {
                    const newX = pieceX + x;
                    const newY = pieceY + y;
                    return newX < 0 || newX >= cols || newY >= rows || gameBoard[newY][newX] !== 0;
                }
                return false;
            });
        });
    }

    function movePiece(direction) {
        pieceX += direction;
        if (collision()) {
            pieceX -= direction;
        }
        drawBoard();
    }

    function dropPiece() {
        pieceY++;
        if (collision()) {
            pieceY--;
            lockPiece();
            generateNewPiece();
        }
        drawBoard();
    }

    function lockPiece() {
        currentPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    gameBoard[pieceY + y][pieceX + x] = currentPiece.color + 1;
                }
            });
        });
        clearLines();
    }

    function rotatePiece() {
        const temp = currentPiece.shape;
        currentPiece.shape = currentPiece.shape[0].map((_, i) => currentPiece.shape.map(row => row[i])).reverse();
        if (collision()) {
            currentPiece.shape = temp;
        }
        drawBoard();
    }

    function clearLines() {
        gameBoard = gameBoard.filter(row => row.some(cell => cell === 0));
        const clearedRows = rows - gameBoard.length;
        if (clearedRows > 0) {
            const newRows = Array.from({ length: clearedRows }, () => Array(cols).fill(0));
            gameBoard = [...newRows, ...gameBoard];
            score += clearedRows * 10;
            document.getElementById("score").textContent = `Puntuaci칩n: ${score}`;
        }
    }

    function gameOver() {
        alert("Game Over");
        gameBoard = Array.from({ length: rows }, () => Array(cols).fill(0));
        score = 0;
        document.getElementById("score").textContent = `Puntuaci칩n: ${score}`;
        generateNewPiece();
    }

    window.addEventListener("keydown", event => {
        switch (event.key) {
            case "ArrowLeft":
                movePiece(-1);
                break;
            case "ArrowRight":
                movePiece(1);
                break;
            case "ArrowDown":
                dropPiece();
                break;
            case "ArrowUp":
                rotatePiece();
                break;
        }
    });

    setInterval(dropPiece, 1000);
    generateNewPiece();
    drawBoard();
</script>

</body>
</html>
